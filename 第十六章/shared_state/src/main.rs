/*
 * @Author: wlj
 * @Date: 2022-12-21 14:35:36
 * @LastEditors: wlj
 * @LastEditTime: 2022-12-21 16:09:03
 * @Description: 共享状态并发
 * @see:https://kaisery.github.io/trpl-zh-cn/ch16-03-shared-state.html
 */

//共享状态并发
//虽然消息传递是一个很好的处理并发的方式，但并不是唯一一个。再一次思考一下 Go 编程语言文档中口号的这一部分：“不要通过共享内存来通讯”（“do not communicate by sharing memory.”）：
//通过共享内存通讯看起来如何？除此之外，为何消息传递的拥护者并不使用它并反其道而行之呢？
//在某种程度上，任何编程语言中的信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值。共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。
//第十五章介绍了智能指针如何使得多所有权成为可能，然而这会增加额外的复杂性，因为需要以某种方式管理这些不同的所有者。
//Rust 的类型系统和所有权规则极大的协助了正确地管理这些所有权。作为一个例子，让我们看看互斥器，一个更为常见的共享内存并发原语。

//互斥器一次只允许一个线程访问数据
//互斥器(mutex)是mutual exclusion 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的锁(lock)来表明其希望访问数据。
//锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统保护（guarding）其数据。
//互斥器以难以使用著称，因为你不得不记住：
//  1.在使用数据之前尝试获取锁
//  2.处理完被互斥器所保护的数据后，必须解锁数据，这样其他线程才能获取锁。
//作为一个现实中互斥器的例子，想象一下在某个会议的一次小组座谈会中，只有一个麦克风。如果一位成员要发言，他必须请求或表示希望使用麦克风。
// 一旦得到了麦克风，他可以畅所欲言，然后将麦克风交给下一位希望讲话的成员。
// 如果一位成员结束发言后忘记将麦克风交还，其他人将无法发言。如果对共享麦克风的管理出现了问题，座谈会将无法如期进行！
//正确的管理互斥器异常复杂，这也是许多人之所以热衷于信道的原因。然而，在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。

//Mutex<T>的 API
//作为展示如何使用互斥器的例子，让我们从在单线程上下文使用互斥器开始
use std::sync::{Arc, Mutex};
use std::thread;
fn learn_mutex() {
    let m = Mutex::new(5); //创建一个互斥器

    {
        let mut num = m.lock().unwrap(); //使用lock方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程直到我们用于锁，如果另一个线程拥有锁，并且那个线程 panic 了，则 lock 调用会失败。在这种情况下，没人能够再获取锁，所以这里选择 unwrap 并在遇到这种情况时使线程 panic。
        *num = 6; //一旦获取了锁，就可以将返回值（在这里是num）视为一个其内部数据的可变引用了。
                  //类型系统确保了我们在使用 m 中的值之前获取锁：Mutex<i32> 并不是一个 i32，所以 必须 获取锁才能使用这个 i32 值。
                  //我们是不会忘记这么做的，因为反之类型系统不允许访问内部的 i32 值。
                  //正如你所怀疑的，Mutex<T> 是一个智能指针。更准确的说，lock 调用 返回 一个叫做 MutexGuard 的智能指针。这个智能指针实现了 Deref 来指向其内部数据；
                  //其也提供了一个 Drop 实现当 MutexGuard 离开作用域时自动释放锁，为此，我们不会忘记释放锁并阻塞互斥器为其它线程所用的风险，因为锁的释放是自动发生的。
    }
    println!("m = {:?}", m); //丢弃了锁之后，可以打印出互斥器的值，并发现能够将其内部的 i32 改为 6。
}

//在线程间共享 Mutex<T>
//现在让我们尝试使用 Mutex<T> 在多个线程间共享值。我们将启动十个线程，并在各个线程中对同一个计数器值加一，这样计数器将从 0 变为 10。
fn learn_threads_mutex() {
    let counter = Arc::new(Mutex::new(0)); //创建了一个 counter 变量来存放内含 i32 的 Mutex<T>
    let mut handles = vec![];

    for _ in 0..10 {
        //不幸的是，Rc<T> 并不能安全的在线程间共享。当 Rc<T> 管理引用计数时，它必须在每一个 clone 调用时增加计数，
        //并在每一个克隆被丢弃时减少计数。Rc<T> 并没有使用任何并发原语，来确保改变计数的操作不会被其他线程打断.
        //在计数出错时可能会导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。我们所需要的是一个完全类似 Rc<T>，又以一种线程安全的方式改变引用计数的类型。
        // let counter = Rc::clone(&counter);

        //原子引用计数 Arc<T>
        //所幸 Arc<T> 正是 这么一个类似 Rc<T> 并可以安全的用于并发环境的类型.字母a 代表原子性 (atomic)，所以这是一个原子引用计数(atomically reference counted)类型。
        //原子性是另一类这里还未涉及到的并发原语：请查看标准库中 std::sync::atomic 的文档来获取更多细节。目前我们只需要知道原子类就像基本类型一样可以安全的在线程间共享。
        //你可能会好奇为什么不是所有的原始类型都是原子性的？为什么不是所有标准库中的类型都默认使用 Arc<T> 实现？原因在于线程安全带有性能惩罚，我们希望只在必要时才为此买单。
        //如果只是在单线程中对值进行操作，原子性提供的保证并无必要，代码可以因此运行的更快。Arc<T> 和 Rc<T> 有着相同的 API
        let counter = Arc::clone(&counter);
        //接下来遍历 range 创建了 10 个线程
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
            //使用了 thread::spawn 并对所有线程使用了相同的闭包：他们每一个都将调用 lock 方法来获取 Mutex<T> 上的锁，
            //接着将互斥器中的值加一。当一个线程结束执行，num 会离开闭包作用域并释放锁，这样另一个线程就可以获取它了。
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap(); //在主线程中，我们像之前 那样收集了所有的 join 句柄，调用它们的 join 方法来确保所有线程都会结束。
    }

    println!("Result: {}", *counter.lock().unwrap());
}

fn main() {
    learn_mutex();
    learn_threads_mutex();

    //RefCell<T>/Rc<T> 与 Mutex<T>/Arc<T> 的相似性
    //你可能注意到了，因为 counter 是不可变的，不过可以获取其内部值的可变引用；这意味着 Mutex<T> 提供了内部可变性，就像 Cell 系列类型那样。
    //正如第十五章中使用 RefCell<T> 可以改变 Rc<T> 中的内容那样，同样的可以使用 Mutex<T> 来改变 Arc<T> 中的内容。
    //另一个值得注意的细节是 Rust 不能避免使用 Mutex<T> 的全部逻辑错误。回忆一下第十五章使用 Rc<T> 就有造成引用循环的风险，这时两个 Rc<T> 值相互引用，造成内存泄漏。
    //同理，Mutex<T> 也有造成 死锁（deadlock） 的风险。这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。
    //如果你对这个主题感兴趣，尝试编写一个带有死锁的 Rust 程序，接着研究任何其他语言中使用互斥器的死锁规避策略并尝试在 Rust 中实现他们。标准库中 Mutex<T> 和 MutexGuard 的 API 文档会提供有用的信息。
    let test = Mutex::new(5);
    let mut a = test.lock().unwrap();
    let mut b = test.lock().unwrap();
    println!("{}", *a); //此时就会造成死锁 因为a 获取了锁 b同时也获取了锁 但是他们却都还没解锁
}
