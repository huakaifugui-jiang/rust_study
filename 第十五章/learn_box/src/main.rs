/*
 * @Author: wlj
 * @Date: 2022-12-19 16:07:02
 * @LastEditors: wulongjiang
 * @LastEditTime: 2022-12-19 23:27:08
 * @Description:使用Box<T>指向堆上的数据
 * @see:https://kaisery.github.io/trpl-zh-cn/ch15-01-box.html#%E4%BD%BF%E7%94%A8boxt%E6%8C%87%E5%90%91%E5%A0%86%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE
 */
//使用Box<T>指向堆上的数据

//最简单直接的智能指针是 box，其类型是 Box<T>。 box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针

//除了数据被存储在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能它们多用于如下场景
// 1.当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
// 2.当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
// 3.当希望拥有一个值并只关心它的类型是否实现了特定的trait而不是其具体类型的时候
//我们会在 “box 允许创建递归类型” 部分展示第一种场景。
//在第二种情况中，转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上，接着，只有少量的指针数据在栈上被拷贝。
//第三种情况被称为 trait 对象（trait object），第十七章刚好有一整个部分 “顾及不同类型值的 trait 对象” 专门讲解这个主题。所以这里所学的内容会在第十七章再次用上！
//如下包含一个 cons list 的枚举定义。
enum List {
    //recursive type has infinite size报错  这个错误表明这个类型 “有无限的大小”。
    //其原因是 List 的一个成员被定义为是递归的：它直接存放了另一个相同类型的值。这意味着 Rust 无法计算为了存放 List 值到底需要多少空间。
    //首先了解一下 Rust 如何决定需要多少空间来存放一个非递归类型
    // 例如
    // enum Message {
    //     Quit,
    //     Move { x: i32, y: i32 },
    //     Write(String),
    //     ChangeColor(i32, i32, i32),
    // }
    // 当 Rust 需要知道要为 Message 值分配多少空间时，它可以检查每一个成员并发现 Message::Quit 并不需要任何空间，
    // Message::Move 需要足够储存两个 i32 值的空间，依此类推。
    // 因为 enum 实际上只会使用其中的一个成员，所以 Message 值所需的空间等于储存其最大成员的空间大小。

    //那递归呢？
    //编译器尝试计算出储存一个 List 枚举需要多少内存，并开始检查 Cons 成员，那么 Cons 需要的空间等于 i32 的大小加上 List 的大小。为了计算 List 需要多少内存，
    //它检查其成员，从 Cons 成员开始。Cons成员储存了一个 i32 值和一个List值，这样的计算将无限进行下去
    //Rust 无法计算出要为定义为递归的类型分配多少空间，所以编译器给出了错误。
    //我们可以看一下报错的help： insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable 插入一些间接的(例如，' Box '， ' Rc '，或' & ')，使' List '可以被描绘
    //因为 Box<T> 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变
    //这意味着可以将 Box 放入 Cons 成员中而不是直接存放另一个 List 值。Box 会指向另一个位于堆上的 List 值,而不是存放在 Cons 成员中。
    //从概念上讲，我们仍然有一个通过在其中 “存放” 其他列表创建的列表，不过现在实现这个概念的方式更像是一个项挨着另一项，而不是一项包含另一项。
    Cons(i32, Box<List>), //Cons 成员将会需要一个 i32 的大小加上储存 box 指针数据的空间。
    Nil,                  //Nil 成员不储存值，所以它比 Cons 成员需要更少的空间。
                          //现在我们知道了任何 List 值最多需要一个 i32 加上 box 指针数据的大小。
                          //通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 List 值需要的大小了。

                          //box 只提供了间接存储和堆分配；他们并没有任何其他特殊的功能，比如我们将会见到的其他智能指针。
                          //它们也没有这些特殊功能带来的性能损失，所以他们可以用于像 cons list 这样间接存储是唯一所需功能的场景。我们还将在第十七章看到 box 的更多应用场景。
                          //Box<T> 类型是一个智能指针，因为它实现了 Deref trait，它允许 Box<T> 值被当作引用对待。
                          //当 Box<T> 值离开作用域时，由于 Box<T> 类型 Drop trait 的实现，box 所指向的堆数据也会被清除。
}
use crate::List::{Cons, Nil};
fn main() {
    //使用Box<T>在堆上存储数据
    let b = Box::new(5); //用box在堆上存储一个i32
    println!("b = {}", b);
    //这里定义了变量 b，其值是一个指向被分配在堆上的值 5 的 Box。这个程序会打印出 b = 5；在这个例子中，我们可以像数据是储存在栈上的那样访问 box 中的数据。
    //正如任何拥有数据所有权的值那样，当像 b 这样的 box 在 main 的末尾离开作用域时，它将被释放。
    //这个释放过程作用于 box 本身（位于栈上）和它所指向的数据（位于堆上）
    //将一个单独的值存放在堆上并不是很有意义，所以像示例 这样单独使用 box 并不常见。
    //将像单个 i32 这样的值储存在栈上，也就是其默认存放的地方在大部分使用场景中更为合适
    //让我们看看一个不使用 box 时无法定义的类型的例子:

    //Box允许创建递归类型
    //Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 递归类型（recursive type）,其值的一部分可以是相同类型的另一个值。
    //这种值的嵌套理论上可以无限的进行下去，所以 Rust 不知道递归类型需要多少空间。
    //不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了
    //让我们探索一下 cons list，一个函数式编程语言中的常见类型，来展示这个（递归类型）概念。
    //除了递归之外，我们将要定义的 cons list 类型是很直白的，所以这个例子中的概念，在任何遇到更为复杂的涉及到递归类型的场景时都很实用

    //cons list是一个来源于Lisp编程语言及其方言的数据结构。在Lisp中，cons 函数（“construct function" 构造函数 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表
    //cons 函数的概念涉及到更常见的函数式编程术语；“将 x 与 y 连接” 通常意味着构建一个新的容器而将 x 的元素放在新容器的开头，其后则是容器 y 的元素。
    //cons list 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 Nil 的值且没有下一项.
    //cons list 通过递归调用 cons 函数产生。代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。注意这不同于第六章中的 “null” 或 “nil” 的概念，他们代表无效或缺失的值。
    //注意虽然函数式编程语言经常使用 cons list，但是它并不是一个 Rust 中常见的类型。大部分在 Rust 中需要列表的时候，Vec<T> 是一个更好的选择。
    //其他更为复杂的递归数据类型 确实 在 Rust 的很多场景中很有用，不过通过以 cons list 作为开始，我们可以探索如何使用 box 毫不费力的定义一个递归数据类型。

    //出于示例的需要我们选择实现一个只存放 i32 值的 cons list。
    //使用这个 cons list 来储存列表 1, 2, 3
    // let list = Cons(1, Cons(2, Cons(3, Nil)));
    //第一个 Cons 储存了 1 和另一个 List 值。这个 List 是另一个包含 2 的 Cons 值和下一个 List 值。接着又有另一个存放了 3 的 Cons 值和最后一个值为 Nil 的 List，非递归成员代表了列表的结尾。
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
