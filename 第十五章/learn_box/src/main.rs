/*
 * @Author: wlj
 * @Date: 2022-12-19 16:07:02
 * @LastEditors: wlj
 * @LastEditTime: 2022-12-19 17:37:41
 * @Description:使用Box<T>指向堆上的数据
 * @see:https://kaisery.github.io/trpl-zh-cn/ch15-01-box.html#%E4%BD%BF%E7%94%A8boxt%E6%8C%87%E5%90%91%E5%A0%86%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE
 */
//使用Box<T>指向堆上的数据

//最简单直接的智能指针是 box，其类型是 Box<T>。 box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针

//除了数据被存储在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能它们多用于如下场景
// 1.当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
// 2.当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
// 3.当希望拥有一个值并只关心它的类型是否实现了特定的trait而不是其具体类型的时候
//我们会在 “box 允许创建递归类型” 部分展示第一种场景。
//在第二种情况中，转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上，接着，只有少量的指针数据在栈上被拷贝。
//第三种情况被称为 trait 对象（trait object），第十七章刚好有一整个部分 “顾及不同类型值的 trait 对象” 专门讲解这个主题。所以这里所学的内容会在第十七章再次用上！

fn main() {
    //使用Box<T>在堆上存储数据
    let b = Box::new(5); //用box在堆上存储一个i32
    println!("b = {}", b);
    //这里定义了变量 b，其值是一个指向被分配在堆上的值 5 的 Box。这个程序会打印出 b = 5；在这个例子中，我们可以像数据是储存在栈上的那样访问 box 中的数据。
    //正如任何拥有数据所有权的值那样，当像 b 这样的 box 在 main 的末尾离开作用域时，它将被释放。
    //这个释放过程作用于 box 本身（位于栈上）和它所指向的数据（位于堆上）
    //将一个单独的值存放在堆上并不是很有意义，所以像示例 这样单独使用 box 并不常见。
    //将像单个 i32 这样的值储存在栈上，也就是其默认存放的地方在大部分使用场景中更为合适
    //让我们看看一个不使用 box 时无法定义的类型的例子:

    //Box允许创建递归类型
    //Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 递归类型（recursive type）,其值的一部分可以是相同类型的另一个值。
    //这种值的嵌套理论上可以无限的进行下去，所以 Rust 不知道递归类型需要多少空间。
    //不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了
    //让我们探索一下 cons list，一个函数式编程语言中的常见类型，来展示这个（递归类型）概念。
    //除了递归之外，我们将要定义的 cons list 类型是很直白的，所以这个例子中的概念，在任何遇到更为复杂的涉及到递归类型的场景时都很实用

    //cons list是一个来源于Lisp编程语言及其方言的数据结构。在Lisp中，cons 函数（“construct function" 构造函数 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表
    //cons 函数的概念涉及到更常见的函数式编程术语；“将 x 与 y 连接” 通常意味着构建一个新的容器而将 x 的元素放在新容器的开头，其后则是容器 y 的元素。
    //cons list 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 Nil 的值且没有下一项.
    //cons list 通过递归调用 cons 函数产生。代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。注意这不同于第六章中的 “null” 或 “nil” 的概念，他们代表无效或缺失的值。
    //注意虽然函数式编程语言经常使用 cons list，但是它并不是一个 Rust 中常见的类型。大部分在 Rust 中需要列表的时候，Vec<T> 是一个更好的选择。
    //其他更为复杂的递归数据类型 确实 在 Rust 的很多场景中很有用，不过通过以 cons list 作为开始，我们可以探索如何使用 box 毫不费力的定义一个递归数据类型。

    //如下包含一个 cons list 的枚举定义。
    enum List {
        Cons(i32, List),
        Nil,
    }
}
