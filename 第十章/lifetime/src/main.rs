/*
 * @Author: wulongjiang
 * @Date: 2022-12-13 21:02:18
 * @LastEditors: wulongjiang
 * @LastEditTime: 2022-12-13 23:26:13
 * @Description:生命周期确保引用有效
 * @see:https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html
 * @FilePath: \lifetime\src\main.rs
 */

//Rust的每一个引用都有其生命周期（lifetime），也就是引用保持有效的作用域。
//大部分时候生命周期都是隐含的  编译器可以推断的，正如大部分类型一样也是可以推断的。
//似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。

fn main() {
    //生命周期的主要目标是避免悬垂引用
    let r; //注意rust是不允许空值的
           // println!("r: {}", r); //所以这里会报错 因为r没有赋值

    {
        let x = 5;
        r = &x; //将值设置为x的引用 报错borrowed value does not live long enough
    } //因为 作用域结束 x被释放了
      // println!("r: {}", r); //而我们在作用域外使用x的引用 所以报错

    //编译器是如何知道 这段代码是不被允许的呢？编译器有一个 借用检查器（borrow checker），它比较作用域来确保所有的作用都是有效的
    //借用器如下 r 和 x 的生命周期注解，分别叫做 'a 和 'b
    // {
    //     let r;                // ---------+-- 'a
    //                           //          |
    //     {                     //          |
    //         let x = 5;        // -+-- 'b  |
    //         r = &x;           //  |       |
    //     }                     // -+       |
    //                           //          |
    //     println!("r: {}", r); //          |
    // }                         // ---------+

    //如你所见，内部的 'b 块要比外部的生命周期 'a 小得多。在编译时，Rust 比较这两个生命周期的大小，
    //并发现 r 拥有生命周期 'a，不过它引用了一个拥有生命周期 'b 的对象。
    //程序被拒绝编译，因为生命周期 'b 比生命周期 'a 要小：被引用的对象比它的引用者存在的时间更短。

    //下面例子的检查器就可以判断出 此代码是可以通过编译的
    // {
    //     let x = 5;            // ----------+-- 'b
    //                           //           |
    //     let r = &x;           // --+-- 'a  |
    //                           //   |       |
    //     println!("r: {}", r); //   |       |
    //                           // --+       |
    // }                         // ----------+

    //函数中的泛型生命周期
    //让我们来编写一个返回两个字符串slice中较长者的函数。者两个函数获取两个字符串slice并返回一个字符串slice
    let string1 = String::from("abcd");
    let result;
    {
        // let string2 = String::from("xyz");
        let string2 = "123"; //疑惑 为什么 这个不报错？？？

        result = longest(string1.as_str(), string2); //此时就会报错//borrowed value does not live long enough 因为result的引用比返回的长，返回的是最短的
    }
    println!("The longest string is {}", result);

}

// fn longest(x: &str, y: &str) -> &str {
//     //报错 ^ expected named lifetime parameter
//     //为什么会报错呢？ 我们可以看报错的提示
//     //this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
//     //这个函数返回一个借来的值（引用），但是签名并没有说他是来自x还是来自y
//     //当我们定义这个函数的时候，并不知道传递给函数的具体值，所以也不知道到底是 if 还是 else 会被执行。
//     // 我们也不知道传入的引用的具体生命周期，所以编译器也就不能 像上面那样通过观察作用域来确定返回的引用是否总是有效。
//      因为如果返回的是x（也就是String1）那么它的生命周期就比较长 如果返回的是y那么它的生命周期就比较断
//     // 借用检查器自身同样也无法确定，因为它不知道 x 和 y 的生命周期是如何与返回值的生命周期相关联的。
//     // 为了修复这个错误，我们将增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。
//     if x.len() > y.len() {
//         x
//     } else {
//         y
//     }
// }

//生命周期注解语法
//生命周期注解并不改变任何引用的生命周期的长短。与当函数签名中指定了泛型类型参数后就可以接受任何类型一样。
//当指定了泛型生命周期后函数也能接受任何生命周期的引用。生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期
//生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（'）开头，其名称通常全是小写，类似于泛型其名称非常短。'a 是大多数人默认使用的名称。
//生命周期参数注解位于引用的 & 之后，并有一个空格来将引用类型与生命周期注解分隔开。
//这里有一些例子：我们有一个没有生命周期参数的 i32 的引用，一个有叫做 'a 的生命周期参数的 i32 的引用，和一个生命周期也是 'a 的 i32 的可变引用：
// &i32        // 引用
// &'a i32     // 带有显式生命周期的引用
// &'a mut i32 // 带有显式生命周期的可变引用

//单个生命周期注解本身没有多少意义，因为生命周期注解告诉Rust多个引用的泛型生命周期参数如何互相练习的。
//例如如果函数有一个生命周期'a的i32的引用的参数first。还有另一个同样是生命周期的'a的i的引用的参数second。这两个生命周期注解意味着引用first和second必须与这泛型生命周期存在的一样久

//函数签名中的生命周期注解
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    //现在函数表明 对于某些生命周期'a,函数会获取两个参数，他们都是与生命周期'a存在的一样长的字符串slice。
    //函数会返回一个同样也与生命周期'a存在一样长的字符串slice。它的实际含义是longest函数返回的引用的生命周期与传入该函数引用的生命周期的较小者一致
    //这些关系就是我们希望Rust分析代码时所使用的

    // 当具体的引用被传递给 longest 时，被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。
    // 换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。
    // 因为我们用相同的生命周期参数 'a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
