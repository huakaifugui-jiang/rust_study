/*
 * @Author: wlj
 * @Date: 2022-12-26 09:36:53
 * @LastEditors: wlj
 * @LastEditTime: 2022-12-26 11:02:30
 * @Description: 宏
 * @see:https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html
 */

// 我们已经在本书中使用过像 println! 这样的宏了，不过还没完全探索什么是宏以及它是如何工作的。
// 宏（Macro）指的是 Rust 中一系列的功能：使用 macro_rules! 的 声明（Declarative）宏，和三种 过程（Procedural）宏：
// 自定义 #[derive] 宏在结构体和枚举上指定通过 derive 属性添加的代码
// 类属性（Attribute-like）宏定义可用于任意项的自定义属性
// 类函数宏看起来像函数不过作用于作为参数传递的 token
// 我们会依次讨论每一种宏，不过首要的是，为什么已经有了函数还需要宏呢？
// 宏和函数的区别
// 从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 元编程（metaprogramming）。
// 元编程从根本上来说，宏是通过一种代码来生成另一种代码，如果大家熟悉元编程，就会发现两者的共同点。
// 在附录 D中讲到的 derive 属性，就会自动为结构体派生出相应特征所需的代码，例如 #[derive(Debug)]，还有熟悉的 println! 和 vec!，所有的这些宏都会展开成相应的代码，且很可能是长得多的代码。
// 总之，元编程可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本，虽然函数复用也有类似的作用，但是宏依然拥有自己独特的优势。

// 可变参数
// Rust 的函数签名是固定的：定义了两个参数，就必须传入两个参数，多一个少一个都不行，对于从 JS/TS 过来的同学，这一点其实是有些恼人的。
// 而宏就可以拥有可变数量的参数，例如可以调用一个参数的 println!("hello")，也可以调用两个参数的 println!("hello {}", name)。

// 宏展开
// 由于宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。
// 而函数就做不到这一点，因为它直到运行时才能被调用，而特征需要在编译期被实现。

// 宏的缺点
// 相对函数来说，由于宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。
fn main() {
    // 声明式宏 macro_rules!
    // 在 Rust 中使用最广的就是声明式宏，它们也有一些其它的称呼，例如示例宏( macros by example )、macro_rules! 或干脆直接称呼为宏。
    // 声明式宏允许我们写出类似 match 的代码。
    // #![allow(unused)]
    // fn main() {
    // match target {
    //     模式1 => 表达式1,
    //     模式2 => {
    //         语句1;
    //         语句2;
    //         表达式2
    //     },
    //     _ => 表达式3
    // }
    // }
    // 宏也是将一个值跟对应的模式进行匹配，且该模式会与特定的代码相关联。但是与 match 不同的是，宏里的值是一段 Rust 源代码(字面量)，
    // 模式用于跟这段源代码的结构相比较，一旦匹配，传入宏的那段源代码将被模式关联的代码所替换，最终实现宏展开。值得注意的是，所有的这些都是在编译期发生，并没有运行期的性能损耗。
    // 简化版的 vec!
    // 在动态数组 Vector 章节中，我们学习了使用 vec! 来便捷的初始化一个动态数组:
    let v: Vec<u32> = vec![1, 2, 3];
    // 最重要的是，通过 vec! 创建的动态数组支持任何元素类型，也并没有限制数组的长度，如果使用函数，我们是无法做到这一点的。
    // 好在我们有 macro_rules!，来看看该如何使用它来实现 vec!，以下是一个简化实现：
    #[macro_export] //#[macro_export] 注释将宏进行了导出，这样其它的包就可以将该宏引入到当前作用域中，
    macro_rules! vec { //紧接着，就使用 macro_rules! 进行了宏定义，需要注意的是宏的名称是 vec，而不是 vec!，后者的感叹号只在调用时才需要。
        ( $( $x:expr ),* ) => {//vec 的定义结构跟 match 表达式很像，但这里我们只有一个分支，其中包含一个模式 ( $( $x:expr ),* )，跟模式相关联的代码就在 => 之后。一旦模式成功匹配，那这段相关联的代码就会替换传入的源代码。
            {//由于 vec 宏只有一个模式，因此它只能匹配一种源代码，其它类型的都将导致报错，而更复杂的宏往往会拥有更多的分支。
                let mut temp_vec = Vec::new();
                $(
                    temp_vec.push($x);
                )*
                temp_vec
            }
        };
    }
    let v2: Vec<u32> = vec![1, 2, 3];
    //模式解析、
    // 而现在，我们先来简单讲解下 ( $( $x:expr ),* ) 的含义。
    // 首先，我们使用圆括号 () 将整个宏模式包裹其中。
    // 紧随其后的是 $()，跟括号中模式相匹配的值(传入的 Rust 源代码)会被捕获，然后用于代码替换。
    // 在这里，模式 $x:expr 会匹配任何 Rust 表达式并给予该模式一个名称：$x。
    // $() 之后的逗号说明在 $() 所匹配的代码的后面会有一个可选的逗号分隔符，
    // 紧随逗号之后的 * 说明 * 之前的模式会被匹配零次或任意多次(类似正则表达式)。
    // 当我们使用 vec![1, 2, 3] 来调用该宏时，$x 模式将被匹配三次，分别是 1、2、3。
    // 为了帮助大家巩固，我们再来一起过一下：
    // $() 中包含的是模式 $x:expr，该模式中的 expr 表示会匹配任何 Rust 表达式，并给予该模式一个名称 $x
    // 因此 $x 模式可以跟整数 1 进行匹配，也可以跟字符串 "hello" 进行匹配: vec!["hello", "world"]
    // $() 之后的逗号，意味着1 和 2 之间可以使用逗号进行分割，也意味着 3 既可以没有逗号，也可以有逗号：vec![1, 2, 3,]
    // * 说明之前的模式可以出现零次也可以任意次，这里出现了三次
    // 接下来，我们再来看看与模式相关联、在 => 之后的代码：
    // {
    //     {
    //         let mut temp_vec = Vec::new();
    //         $(
    //             temp_vec.push($x);
    //         )*
    //         temp_vec
    //     }
    // };
    // 这里就比较好理解了，$() 中的 temp_vec.push() 将根据模式匹配的次数生成对应的代码，当调用 vec![1, 2, 3] 时，下面这段生成的代码将替代传入的源代码，也就是替代 vec![1, 2, 3] :
    // {
    //     let mut temp_vec = Vec::new();
    //     temp_vec.push(1);
    //     temp_vec.push(2);
    //     temp_vec.push(3);
    //     temp_vec
    // }
    // 如果是 let v = vec![1, 2, 3]，那生成的代码最后返回的值 temp_vec 将被赋予给变量 v，等同于 :
    // let v = {
    //     let mut temp_vec = Vec::new();
    //     temp_vec.push(1);
    //     temp_vec.push(2);
    //     temp_vec.push(3);
    //     temp_vec
    // }
    // 至此，我们定义了一个宏，它可以接受任意类型和数量的参数，并且理解了其语法的含义。
    // 未来将被替代的 macro_rules
    // 对于 macro_rules 来说，它是存在一些问题的，因此，Rust 工作方式类似，但是解决了目前存在的一些问题，在那之后，macro_rules 将变为 deprecated 状态。
    // 由于绝大多数 Rust 开发者都是宏的用户而不是编写者，因此在这里我们不会对 macro_rules 进行更深入的学习，如果大家感兴趣，可以看看这本书 “The Little Book of Rust Macros”。
    // 用过程宏为属性标记生成代码
    // 第二种常用的宏就是过程宏 ( procedural macros )，从形式上来看，过程宏跟函数较为相像，但过程宏是使用源代码作为输入参数，基于代码进行一系列操作后，再输出一段全新的代码。
    // 注意，过程宏中的 derive 宏输出的代码并不会替换之前的代码，这一点与声明宏有很大的不同！
    // 至于前文提到的过程宏的三种类型(自定义 derive、属性宏、函数宏)，它们的工作方式都是类似的。
    // 当创建过程宏时，它的定义必须要放入一个独立的包中，且包的类型也是特殊的，这么做的原因相当复杂，大家只要知道这种限制在未来可能会有所改变即可。
    // 事实上，根据这个说法，过程宏放入独立包的原因在于它必须先被编译后才能使用，如果过程宏和使用它的代码在一个包，就必须先单独对过程宏的代码进行编译，然后再对我们的代码进行编译，但悲剧的是 Rust 的编译单元是包，因此你无法做到这一点。
    // 假设我们要创建一个 derive 类型的过程宏：
    // use proc_macro;

    // #[proc_macro_derive(HelloMacro)]
    // pub fn some_name(input: TokenStream) -> TokenStream {
    // }
    // 用于定义过程宏的函数 some_name 使用 TokenStream 作为输入参数，并且返回的也是同一个类型。TokenStream 是在 proc_macro 包中定义的，顾名思义，它代表了一个 Token 序列。
    // 在理解了过程宏的基本定义后，我们再来看看该如何创建三种类型的过程宏，首先，从大家最熟悉的 derive 开始。
    // 自定义 derive 过程宏
    // 假设我们有一个特征 HelloMacro，现在有两种方式让用户使用它：
    // 为每个类型手动实现该特征，就像之前特征章节所做的
    // 使用过程宏来统一实现该特征，这样用户只需要对类型进行标记即可：#[derive(HelloMacro)]
    // 以上两种方式并没有孰优孰劣，主要在于不同的类型是否可以使用同样的默认特征实现，如果可以，那过程宏的方式可以帮我们减少很多代码实现:
    use hello_macro_derive::HelloMacro;

    pub trait HelloMacro {
        fn hello_macro();
    }
    #[derive(HelloMacro)]
    struct Sunfei;

    #[derive(HelloMacro)]
    struct Sunface;

    Sunfei::hello_macro();
    Sunface::hello_macro();

    // 类属性宏(Attribute-like macros)
    // 类属性过程宏跟 derive 宏类似，但是前者允许我们定义自己的属性。此之外，derive 只能用于结构体和枚举，而类属性宏可以用于其它类型项，例如函数。
    // 假设我们在开发一个 web 框架，当用户通过 HTTP GET 请求访问 / 根路径时，使用 index 函数为其提供服务:
    // #[route(GET, "/")]
    // fn index() { }
    // 如上所示，代码功能非常清晰、简洁，这里的 #[route] 属性就是一个过程宏，它的定义函数大概如下：
    // #[proc_macro_attribute]
    // pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
    // 与 derive 宏不同，类属性宏的定义函数有两个参数：
    // 第一个参数时用于说明属性包含的内容：Get, "/" 部分
    // 第二个是属性所标注的类型项，在这里是 fn index() {...}，注意，函数体也被包含其中
    // 除此之外，类属性宏跟 derive 宏的工作方式并无区别：创建一个包，类型是 proc-macro，接着实现一个函数用于生成想要的代码。
    // 类函数宏(Function-like macros)
    // 类函数宏可以让我们定义像函数那样调用的宏，从这个角度来看，它跟声明宏 macro_rules 较为类似。
    // 区别在于，macro_rules 的定义形式与 match 匹配非常相像，而类函数宏的定义形式则类似于之前讲过的两种过程宏:
    // #[proc_macro]
    // pub fn sql(input: TokenStream) -> TokenStream {
    // 而使用形式则类似于函数调用:
    // let sql = sql!(SELECT * FROM posts WHERE id=1);
    // 大家可能会好奇，为何我们不使用声明宏 macro_rules 来定义呢？原因是这里需要对 SQL 语句进行解析并检查其正确性，这个复杂的过程是 macro_rules 难以对付的，而过程宏相比起来就会灵活的多。
}
