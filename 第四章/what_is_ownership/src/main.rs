/*
 * @Author: wlj
 * @Date: 2022-12-02 15:02:10
 * @LastEditors: wulongjiang
 * @LastEditTime: 2022-12-04 17:42:23
 * @Description: 什么是所有权？
 * @see：https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html
 */

//所有程序都必须管理其运行时使用计算机内存的方式。 在Rust没出来之前一共有两个方式对内存管理
//一些语言中具有垃圾回收机制(GC)通过一些算法（如引用计数法等）对内存进行管理 如js，java，go
//在另一些语言，程序员必须亲自分配和释放内存， 如C C++。

//Rust 另辟蹊径 选择了第三种方式：通过所有权（ownership）系统来管理内存，编译器在编译时会根据一系列的规则进行检查。
//如果违反了任何这些规则，程序都不能编译。并且在运行时，所有权系统的任何功能都不会减慢程序。

//什么是所有权系统呢？
//我们得先来简单的了解一些堆与栈。
//堆和栈都是运行时可供使用的内存，但是他们的结构不太一样

//栈 stack
// 栈以放入值的顺序存储并且以相反的顺序取出值。这也被称作后进先出（LILO:first in last out).
// 可以简单想象就比如 子弹弹夹 先装入的子弹都是最后射出的。  或者叠盘子：当增加更多的盘子时都是放在盘子的顶部，当需要的时候拿出盘子，也是先从顶部拿走。！不能从中间也不能从底部增加或拿走盘子！
// 这样增加的数据叫做  进栈 (pushing onto the stack)或压栈，而移出数据叫做出栈（popping off the stack）.
// 要注意的是 栈中的所有数据都必须占用 已知 且 固定 的大小，是静态的。 因为栈的存储容量是有限的

//堆 heap
// 所以 因为 栈只能存放固定大小的数据，那么一些不确定大小的数据要存放在哪里呢？ 答案就是堆。
// 当向堆放入数据时，你需要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，
//！！！并且返回一个表示该位置地址的指针（pinter）。这个过程称作 在堆上分配内存（allocating on the heap）有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。这是动态的。
// 因为 指向堆中数据的 指针 是已知的且大小固定的，你可以讲该指针存储在 栈 上。 当需要实际数据时，必须访问指针
// 想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。

//入栈比在堆上分配内存要快，因为（入栈时）分配器不需要去 为存储新的数据而去搜索内存空间。它的位置总是在栈顶。
//相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备

//同理的 访问堆上的数据比访问栈上的数据慢，因为它必须先到栈中去 获取 指针 来访问。]

//！！要注意的是 栈内存会被系统自动回收，而堆内存则不会，所以需要GC或者手动回收 或者所有权系统。

//当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。

//跟踪 哪部分代码 正在使用堆上的 哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上 不再使用的数据 确保不会耗尽空间，这些问题正是所有权系统需要处理的。
//一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的主要目的就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。

// 所有权的规则：
//1.Rust中的每一个值都有一个所有者（owner）。
//2.值在任一时刻有且只有一个所有者。
//3.当所有者（变量）离开作用域，这个值将被丢弃。

//变量作用域
fn learn_variables_scope() {
    //s在这里无效，它还没有声名。
    // println!("s:{s}"); cannot find value `s` in this scope
    let s = "hello"; // 从此处起，s 是有效的
    println!("s:{s}");
} // 此作用域已结束，s 不再有效

//String类型
//为了演示所有权的规则，我们需要一个比第三章复杂的数据类型。前面介绍的类型的大小都是已知的，可以存储在栈中。并且当离开作用域时被移出栈，
//如果代码的另一部分需要在不同的作用域使用相同的值，可以快速地复制来创建一个独立的实例。
//为了演示所以我们需要找一个存储在堆上的数据来探索Rust的所有权。
//但是这里要区分一下，我们已经使用过字符串字面量
///如：let str = "123";这是一个字符串字面量，因为它是固定长度的，而且不会改变的，我们在编译时就知道它的内容，！！！所以文本直接硬编码到最终的可执行文件中。
// String类型不一样 它存储在堆中 大小是未知的。例如，想获取用户输入并存储

//补充：为什么都说JavaScript的字符串是栈存储呢，其实是因为v8引擎做了优化，它通过将字符串

fn learn_string_type() {
    //例如
    let mut s = String::from("hello");
    //这两个冒号 :: 是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）下，
    // 而不需要使用类似 string_from 这样的名字。在第五章的 “方法语法”（“Method Syntax”）
    // 部分会着重讲解这个语法而且在第七章的 “路径用于引用模块树中的项” 中会讲到模块的命名空间。
    s.push_str(",world"); //在字符串后面追加字面量
    println!("s:{s}");
}

//内存与分配
//就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。
//这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。

//所以对于String类型，为了支持一个可变，可增长的文本片段，我们需要在堆上分配一块在编译时未知大小的内存来存放内容。这也就意味着。我们需要
//1.必须在运行时向内存分配器（memory allocator）请求内存。
//2.当我们使用完String时将内存返回给分配器的方法（释放内存。）

//第一步 由我们完成 当调用String::from时，它实现请求其所需的内存。
//但是第二步就有区别了，向上面说的，在有垃圾回收（GC）的语言中，GC记录并且清除不再使用的内存，我们并不需要关心它。
//但是在没有GC的语言中，别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。
//从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。
//如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 (分配)allocate 配对一个 free。

//Rust采用的策略是，内存在拥有它的变量离开作用域后就被自动释放。

fn learn_memory_allocator() {
    //变量与数据交互的方式(一)：移动
    //在Rust 中，多个变量可以采取不同的方式与同一数据进行交互。例如
    let x = 5; //将值5绑定给x；
    let y = x; //生成一个值x的拷贝并且绑定给y；
               //所以现在有了变量，x 和 y，都等于 5。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中。

    //  String版本：
    let s1 = String::from("hello_memory_allocator"); //此时会在栈和堆上分别开辟一个空间。
                                                     //栈上存放（1.指向存放字符串内容（堆）的指针2.一个长度（表示当前String使用了多少字节的内存）3.一个容量（String从分配器总共获取了多少字节的内存）；
                                                     //具体查看main.drawio

    let s2 = s1; //此时的s1 被移到到了s2 所以s1 无效
                 //如果是浅拷贝的话，两个数据指针指向了同一位置。这就有了一个问题：当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。
                 //这是一个叫做 二次释放（double free）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，
                 //它可能会导致潜在的安全漏洞。
                 // 为了确保内存安全，在 let s2 = s1 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。
                 // 所以上面的 let s2 = s1 表现在Rust中是 s1被 移动 到了s2中，而不是其他语言的浅拷贝 深拷贝
                 //println!("{}, world!", s1); //报错value borrowed here after move
    println!("s2 = {}", s2);
    //另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。

    //变量与数据交互的方式（二）：克隆
    //如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。
    //第五章会讨论方法语法，不过因为方法在很多语言中是一个常见功能，所以之前你可能已经见过了。
    let c1 = String::from("hello_clone");
    let c2 = c1.clone();
    println!("c1 = {}, c2 = {}", c1, c2);

    //为什么 let x = 5;  let y = x; 没有调用 clone，不过 x 依然有效且没有被移动到 y 中。
    //原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。换句话说，这里没有深浅拷贝的区别，
    //所以这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它。

    //要注意的是： ！！！！
    //Rust 有一个叫做 Copy trait(中文：特质，特征) 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章将会详细讲解 trait）。
    //如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
    //Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。
    //如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。要学习如何为你的类型添加 Copy 注解以实现该 trait，
    //请阅读附录 C 中的 “可派生的 trait”[https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html]。
    //     那么哪些类型实现了 Copy trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：

    // 所有整数类型，比如 u32。
    // 布尔类型，bool，它的值是 true 和 false。
    // 所有浮点数类型，比如 f64。
    // 字符类型，char。
    // 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。
} //当s离开作用域时，也就是这里，当变量离开作用域，Rust为我们调用一个  特殊的函数。这个函数叫做drop[https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop] 在这里String 的作者可以放置释放内存的代码
  //注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）。如果你使用过 RAII 模式的话应该对 Rust 的 drop 函数并不陌生。

//所有权与函数 将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。
fn learn_overship_fn(some_string: String) {
    // some_string 进入作用域
    println!("some_string : {}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

//copy 变量
fn learn_copy_fn(some_num: u32) {
    // some_num 进入作用域
    println!("some_num : {}", some_num);
} // some_num 移出作用域。没有特殊之处

//返回值与作用域   返回值也可以转移所有权
fn learn_overship_back() -> String {
    let some_string = String::from("yours"); // some_string 进入作用域.
    some_string // 返回 some_string
                // 并移出给调用的函数
}

//将传入字符串并返回该值
fn learn_takes_and_gives_back(a_string: String) -> String {
    // a_string 进入作用域
    a_string // 返回 a_string 并移出给调用的函数
}

fn main() {
    learn_variables_scope();
    learn_string_type();
    learn_memory_allocator();

    //所有权与函数
    let s = String::from("learn_overship_fn"); //s进入作用域
    learn_overship_fn(s); //s的值被移动到函数中
                          //println!("s: {}", s) //报错 value borrowed here after move 所以s在这里不再有效

    let x = 5;
    learn_copy_fn(x); //因为u32是copy的
    println!("learn_copy_fn x : {}", x); //所以在这可以继续使用x

    let s1 = learn_overship_back(); // learn_overship_back 将返回值
                                    // 转移给 s1

    let s2 = String::from("hello"); // s2 进入作用域

    let s3 = learn_takes_and_gives_back(s2); // s2 被移动到
                                             // learn_takes_and_gives_back 中,

    //演示到这里，总感觉这个函数在使用所有权时十分麻烦，每次都需要返回才能继续调用原本的变量。
    //幸运的是，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 引用（references）。 下一个章节演示。
} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走.s1 离开作用域并被丢弃
  // 没有特殊之处
